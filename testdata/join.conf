%include "ldap.conf"

Datenquellen(

  Datenquelle(
    NAME "MitarbeiterDieNichtImLDAPStehen"
    TYPE "conf"
    SUBTYPE "ordered"
    URL "phantome.conf"
    Schluessel("Vorname" "Nachname" "Rolle")
  )
  
  Datenquelle(
    NAME "Personal"
    TYPE "union"
    SOURCE1 "MitarbeiterDieNichtImLDAPStehen"
    SOURCE2 "ldap"
      # Achtung! Wenn in SOURCE1 und SOURCE2 Datensätze mit dem selben
      # Schlüsselwert sind, so kann dies unerwünschte Folgen haben.
      # Im Briefkopfsystem zum Beispiel würde das Hinzufügen eines der
      # Datensätze zur persönlichen Absenderliste beim nächsten Neustart
      # dazu führen, dass alle Datensätze mit dem entsprechenden Schlüssel
      # auf der Absenderliste sind.
  )

  Datenquelle(
    NAME "LDAPFixes"
    TYPE "conf"
    URL "ldapfixes.conf"
    Schluessel("OID")
  )
  
  Datenquelle(
    NAME "ldap_gefixt"
    TYPE "prefer"
    SOURCE "LDAPfixes"
    OVER "ldap"
    MATCH("OID" "OID")
     # Achtung! Eine "prefer"-Datenquelle funktioniert nur zuverlässig,
     # wenn das Schema von OVER exakt dem von SOURCE entspricht und
     # insbesondere auch die Schlüssel identisch sind.
  )

  Datenquelle( 
    NAME "verkehrsverbindungen"
    TYPE "conf"
    SUBTYPE "ordered"
    URL "verkehrsverbindungen.conf"
    Schluessel("Adresse")
  )


  Datenquelle(
    NAME "PersonalMitVerkehrsverbindungen"

    TYPE "attach"
    
    SOURCE "ldap"
    ATTACH "verkehrsverbindungen"
    MATCH ("Dienstgebaeude" "Adresse")
    
      # Zur Erstellung der Menge der Ergebnisdatensätze
      # wird jeder Datensatz aus SOURCE1 genau einmal verwendet und 
      # jeder Datensatz aus SOURCE2 beliebig oft (auch keinmal).
      # Unterschiede zu einem richtigen Join:
      #  a) Verhindert, dass eine Person 2 mal auftaucht, nur weil es 2 
      #     Einträge mit Verkehrsverbindungen für ihre Adresse gibt
      #  b) Verhindert, dass eine Person rausfliegt, weil es zu ihrer 
      #     Adresse keine
      #     Verkehrsverbindung gibt
      # c) Die Schlüssel der Ergebnisdatensätze bleiben die aus SOURCE1
      #    und werden nicht kombiniert aus SOURCE1 und SOURCE2. Das 
      #    verhindert wird, dass ein Datensatz bei einer Änderung der 
      #    Adresse aus der lokalen Absenderliste fliegt, weil er beim 
      #    Cache-Refresh nicht mehr gefunden wird.
      #
      # In der Ergebnisdatenquelle sind alle Spalten von SOURCE1 unter
      # ihrem ursprünglichen Namen, alle Spalten von SOURCE2 unter dem
      # Namen von SOURCE2 konkateniert mit "." konkateniert mit dem
      # Spaltennamen zu finden.
      #
      # Argument gegen automatische Umbenennung/Aliase für Spalten aus
      # SOURCE2, deren Name sich nicht mit einer Spalte aus SOURCE1 stört:
      # - Der Alias würde verschwinden, wenn die Quelle SOURCE1 später einmal
      #   um eine Spalte mit dem entsprechenden Namen erweitert wird.
      #   Definitionen, die den Alias verwendet haben verwenden ab da 
      #   stillschweigend die Spalte aus SOURCE1, was schwierig zu findende
      #   Fehler nach sich ziehen kann.
  )


  
  Datenquelle(
    NAME "Personal"
    TYPE "rename"
    SOURCE "PersonalMitVerkehrsverbindungen"
    Spalten(
      ("verkehrsverbindungen.OPNV1" "OPNV1")
      ("verkehrsverbindungen.OPNV2" "OPNV2")
      ("verkehrsverbindungen.OPNV3" "OPNV3")
      ("verkehrsverbindungen.OPNV4" "OPNV4")
    )
    
     # Achtung! Wird eine Spalte "A" umbenannt in "B", so ist eine evtl.
     # vorher existierende Spalte "B" damit unerreichbar geworden.
     # Ist "B" eine Schlüsselspalte, so ist undefiniert, ob sich dadurch
     # auch die Schlüssel ändern, oder ob die Schlüssel weiterhin den
     # Werten der alten Spalte B entsprechen.
  )
  
)
